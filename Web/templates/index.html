<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PIT-A-PAT</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            background-color: #f0f0f0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
        }
        .chatbox {
            display: none; /* 챗봇 창은 초기에 숨겨둠 */
            width: 400px;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }
        .chatbox-header {
            background-color: #7453b6;
            color: #fff;
            padding: 10px;
            text-align: center;
            font-weight: bold;
        }
        .chatbox-body {
            padding: 20px;
            height: 300px;
            overflow-y: scroll;
        }
        .chatbox-footer {
            display: flex;
            align-items: center;
            padding: 10px;
            background-color: #f0f0f0;
        }
        .message {
            margin: 10px;
            padding: 8px 12px;
            border-radius: 5px;
            max-width: 70%;
        }
        .message.system {
            background-color: #fff;
            text-align: center;
            font-style: italic;
            color: #666;
        }
        .message.user {
            background-color: #e3d6fe;
            align-self: flex-end;
        }
        .message.assistant {
            background-color: #e9dfff;
        }
        .input-box {
            flex-grow: 1;
            margin: 0 10px;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 5px;
            font-size: 14px;
        }
        .send-button {
            padding: 8px 16px;
            background-color: #b998ff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        .start-button {
            padding: 12px 24px;
            background-color: #b998ff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        .learning-section {
            display: none;
            padding: 20px;
            background-color: #fff;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
            margin-top: 20px;
        }
        .waveform-canvas {
            margin-top: 20px;
            width: 100%;
            height: 200px;
            background-color: #f0f0f0;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }
    </style>
</head>
<body>
    <button onclick="startChat()" class="start-button">시작하기</button>

    <div class="chatbox" id="chatbox">
        <div class="chatbox-header">챗봇 대화</div>
        <div class="chatbox-body" id="chatbox-body"></div>
        <div class="chatbox-footer">
            <input type="text" id="userInput" class="input-box" placeholder="메시지를 입력하세요...">
            <button onclick="sendMessage()" class="send-button">보내기</button>
            <button onclick="endChat()" class="send-button">대화 종료</button>
        </div>
    </div>

    <div class="learning-section" id="learningSection">
        <h2>학습하기</h2>
        <div id="translatedResults"></div>
        <button onclick="nextMessage()">다음 문장</button>
        <button onclick="startRecording()" id="recordBtn">녹음하기</button>
        <button onclick="stopRecording()" id="stopBtn" disabled>녹음 종료</button>
        <canvas id="waveform" class="waveform-canvas"></canvas>
        <canvas id="comparisonWaveform" class="waveform-canvas"></canvas>
        <button onclick="textToSpeech()">TTS 변환</button>
    </div>

    <script>
        const startButton = document.querySelector('.start-button');
        const chatbox = document.getElementById('chatbox');
        const chatboxBody = document.getElementById('chatbox-body');
        const userInput = document.getElementById('userInput');
        const learningSection = document.getElementById('learningSection');
        const translatedResults = document.getElementById('translatedResults');
        const recordBtn = document.getElementById('recordBtn');
        const stopBtn = document.getElementById('stopBtn');
        const waveformCanvas = document.getElementById('waveform');
        const comparisonWaveformCanvas = document.getElementById('comparisonWaveform');

        function startChat() {
            startButton.style.display = 'none';  // 시작하기 버튼 숨김
            chatbox.style.display = 'block';     // 챗봇 창 표시
        }

        function endChat() {
            chatbox.style.display = 'none';      // 챗봇 창 숨김
            startButton.style.display = 'block'; // 시작하기 버튼 표시
            chatboxBody.innerHTML = '';          // 채팅 내용 초기화
            learningSection.style.display = 'block';  // 학습하기 섹션 표시
        }

        function appendMessage(role, message) {
            const messageElement = document.createElement('div');
            messageElement.classList.add('message', role);
            messageElement.innerText = message;
            chatboxBody.appendChild(messageElement);
            chatboxBody.scrollTop = chatboxBody.scrollHeight;
        }

        async function sendMessage() {
            const message = userInput.value.trim();
            if (message) {
                appendMessage('user', message);
                userInput.value = '';

                try {
                    const response = await sendMessageToChat(message);
                    appendMessage('assistant', response.response);
                } catch (error) {
                    console.error('Error sending message:', error);
                    appendMessage('system', '메시지 전송 중 오류가 발생했습니다.');
                }
            }
        }

        async function sendMessageToChat(message) {
            const response = await fetch('/chat', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ message: message })
            });
            return await response.json();
        }

        async function endChatAndTranslate() {
            // 챗봇 대화 종료 및 번역된 결과 표시
            const messages = Array.from(chatboxBody.querySelectorAll('.message.user')).map(msg => msg.innerText.split(': ')[1]);
            const translatedResults = await translateMessages(messages);

            // 번역 결과 출력
            displayTranslatedResults(translatedResults);
        }

        async function translateMessages(messages) {
            const translations = [];
            for (const message of messages) {
                try {
                    const response = await fetch('/translate', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({ message: message })
                    });
                    if (!response.ok) {
                        throw new Error('Failed to translate message');
                    }
                    const data = await response.json();
                    translations.push({ dialect: message, standard: data.standard_text });
                } catch (error) {
                    console.error('Error translating message:', error);
                    translations.push({ dialect: message, standard: '번역 실패' });
                }
            }
            return translations;
        }

        function displayTranslatedResults(results) {
            translatedResults.innerHTML = '';
            results.forEach(result => {
                const div = document.createElement('div');
                div.textContent = `사투리: ${result.dialect}, 표준어: ${result.standard}`;
                translatedResults.appendChild(div);
            });
        }

        async function startRecording() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                const mediaRecorder = new MediaRecorder(stream);
                const chunks = [];

                mediaRecorder.ondataavailable = function(e) {
                    chunks.push(e.data);
                    visualizeLiveAudio(e.data);
                };

                mediaRecorder.onstop = function() {
                    const blob = new Blob(chunks, { type: 'audio/wav' });
                    const audioUrl = URL.createObjectURL(blob);
                    visualizeRecordedAudio(audioUrl);
                    visualizeComparisonAudio();
                };

                mediaRecorder.start();
                recordBtn.disabled = true;
                stopBtn.disabled = false;
            } catch (error) {
                console.error('Error starting recording:', error);
            }
        }

        function stopRecording() {
            mediaRecorder.stop();
            recordBtn.disabled = false;
            stopBtn.disabled = true;
        }

        function visualizeLiveAudio(data) {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const reader = new FileReader();

            reader.onload = function(e) {
                audioContext.decodeAudioData(e.target.result, function(buffer) {
                    const canvas = waveformCanvas;
                    visualizeBuffer(buffer, canvas);
                });
            };

            reader.readAsArrayBuffer(data);
        }

        function visualizeRecordedAudio(audioUrl) {
            const audio = new Audio(audioUrl);
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const analyser = audioContext.createAnalyser();
            const canvas = waveformCanvas;
            const audioSrc = audioContext.createMediaElementSource(audio);

            audioSrc.connect(analyser);
            audioSrc.connect(audioContext.destination);
            audio.play();

            visualizeBuffer(analyser, canvas);
        }

        async function visualizeComparisonAudio() {
            const response = await fetch('/deepvoice');
            const audioData = await response.arrayBuffer();

            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const buffer = await audioContext.decodeAudioData(audioData);
            const canvas = comparisonWaveformCanvas;

            visualizeBuffer(buffer, canvas);
        }

        function visualizeBuffer(buffer, canvas) {
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            const data = buffer.getChannelData(0);
            const step = Math.ceil(data.length / width);
            const amp = height / 2;

            ctx.clearRect(0, 0, width, height);
            ctx.beginPath();
            ctx.moveTo(0, height / 2);

            for (let i = 0; i < width; i++) {
                const min = 1.0;
                const max = -1.0;
                let y = (data[(i * step) | 0] - min) / (max - min) * amp;
                if (y > height) y = height;
                if (y < 0) y = 0;
                ctx.lineTo(i, y);
            }

            ctx.stroke();
        }

        function nextMessage() {
            // 다음 문장을 표시하거나 추가적인 기능 구현
            console.log('Implement next message functionality here');
        }

        async function textToSpeech() {
            // TTS 변환 기능 구현
            const currentUrl = window.location.href;      
            const url = new URL(currentUrl); 
            url.port = '6969';
            window.open(url.toString(), '_blank');      
        }
        
    </script>
</body>
</html>
